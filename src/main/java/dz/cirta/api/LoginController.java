package dz.cirta.api;

import dz.cirta.api.configures.web.serializers.TempRequestBody;
import dz.cirta.service.IBusinessLogic;
import dz.cirta.store.models.CirtaUser;
import dz.cirta.store.models.DeletionRequestStatus;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Scope;
import org.springframework.context.annotation.ScopedProxyMode;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.social.connect.ConnectionRepository;
import org.springframework.social.connect.UsersConnectionRepository;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.view.RedirectView;

import java.time.Instant;
import java.time.ZonedDateTime;
import java.util.Date;
import java.util.Optional;


/**
 * front controller used for authenticating users coming only from <a href="https://mobile.cirta.app">cirta mobile app</a>.
 * <br> in order to generate and attribute an access token to a valid user, relative {@link dz.cirta.store.models.TempAuthentication} is retrieval.<br>
 * valid user is everyone who uses <a href="https://mobile.cirta.app">cirta mobile app</a> and seeking secured urls such as: /search or /book <br>
 * {@link dz.cirta.store.models.TempAuthentication} holds a random uniq key generated by the help of {@link Math},
 * one association between {@link CirtaUser} and {@link dz.cirta.store.models.TempAuthentication} means first step of authentication is successfully established.<br>
 * second and final step of authentication is redirecting the user after receiving {@link AuthResponse} containing generated key from first step.
 * @author Abdessamed Diab
 * @version 2.0
 * @since 1.0
 * @see dz.cirta.api.configures.OAuth.SignInProviderConfigurer for more details.
 */
@RestController
public class LoginController {
   private final static Logger logger = LoggerFactory.getLogger(LoginController.class);

   /**
    * secret like salt for generating passwords
    */
   @Value("${app.jwt.secret}")
   private String secret;

   /**
    * domain name of <a href="https://mobile.cirta.app">cirta mobile app</a>
    */
   @Value("${mobile.cirta.app.dns}")
   private String frontDns;

   @Autowired
   private Environment env;

   @Autowired
   private UsersConnectionRepository usersConnectionRepository;

   @Autowired
   private IBusinessLogic businessLogic;

   /**
    * second step of authenticating a valid user.
    * <br> this should be called once the browser received a key {@link dz.cirta.store.models.TempAuthentication}.
    * @param body of type {@link TempRequestBody} holding a key and other necessary information.
    * @param language 1 or 0 describing preferred language.
    * @return {@link AuthResponse} contains a new generated access token for exchanging data for coming http requests.
    */
   @PostMapping(path = "/login", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
   public ResponseEntity<AuthResponse> login(
         @RequestBody(required = true) final TempRequestBody body,
         @RequestHeader(name = "language", required = true) final int language) {

      CirtaUser cirtaUser = Optional.ofNullable(
            businessLogic.findUserByTempAuthenticationKey(body.getKey())
      ).orElse(
            businessLogic.findUserByNameAndPassword(body.getUsername(), body.getPassword())
      );

      final byte lang = (byte) (1 == language ? 1 : 0);
      if (cirtaUser == null) {
         logger.warn("anonymous user tried to get valid jwt using: " + body.toString());
         return new ResponseEntity<AuthResponse>(new AuthResponse().setJwtToken("empty", lang), HttpStatus.NOT_FOUND);
      }

      cirtaUser.setTempAuthentication(null);
      cirtaUser.setLanguage((byte) language);
      businessLogic.saveOrUpdate(cirtaUser);

      return new ResponseEntity<AuthResponse>(new AuthResponse().setJwtToken(createTokenForUser(cirtaUser), lang), HttpStatus.OK);
   }

   // TODO ad we should clear connections from repository when user disconnect.
   @Bean(name = "connectionRepository")
   @Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES)
   public ConnectionRepository connectionRepository() {
      Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
      if (authentication == null) {
         throw new IllegalArgumentException("unable to find connectionRepository: no user signed in.");
      }

      return usersConnectionRepository.createConnectionRepository(authentication.getName());
   }

   /**
    * generate a uniq access token based on {@link CirtaUser} identifier.
    * @param user for whom the access token should be attached to
    * @return newly created access token
    */
   private String createTokenForUser(final CirtaUser user) {
      Instant duration = null;
      switch (env.getActiveProfiles()[0]) {
         case "prod":
            duration = ZonedDateTime.now().plusMinutes(5).toInstant();
            break;
         default:
            duration = ZonedDateTime.now().plusHours(2).toInstant();
      }

      return Jwts.builder()
            .setSubject(String.valueOf(user.getId()))
            .setExpiration(Date.from(duration))
            .signWith(SignatureAlgorithm.HS512, secret)
            .compact();
   }

   /**
    * handle facebook data deletion request.
    * <br>delete user's data stored in the system.
    * one of requirements of using facebook login is to provide a valid endpoint for handling users data deletion request.
    * @param callbackBody contains user identifier
    * @return a valid http code like 200 or 202 confirming that the deletion operation is finished successfully.
    */
   @PostMapping(path = "/dataDeletionRequest", produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE)
   public DeletionRequestStatus dataDeletionRequest(HttpEntity<String> callbackBody) {
      return new DeletionRequestStatus("https://mobile.cirta.app", "200");
   }

   /**
    * when the user submitted bad Facebook credentials, automatically he should be redirected to login page.
    * @return {@link RedirectView} representing login page.
    */
   @GetMapping(path = "/signin*")
   public RedirectView redirectToIndex() {
      LoggerFactory.getLogger(getClass())
            .warn("the user has been redirected to signin end point, because facebook based OAth2 authentication failed.");
      return new RedirectView(frontDns);
   }

   private class AuthResponse {
      public String jwtToken;
      public String csrfToken;
      public int language;

      // we are not in the same domain, #1 front dont have access to hor-domain cookies, and #2 we have a stat-less sessions.
      // in other words we should secure app without activating csrf filter, instead by providing another approach.
      public AuthResponse() {
      }

      private AuthResponse setJwtToken(String jwtToken, int language) {
         this.jwtToken = jwtToken;
         this.language = language;
         return this;
      }

      private AuthResponse setCsrfToken(String csrfToken) {
         this.csrfToken = csrfToken;
         return this;
      }
   }
}
